# # import Num_py as np

# # # example = list(range(5000))
# # # [i*i for i in example] ## долго

# # example = np.arange(5000)
# # example*example

# #Создание массива
# # a = np.asarray(a)
# # 2*a

# # a = np.array([1,2,3,4,5]) #массив из списка
# #  один тип данных желателен (int, float, object, binary)
# # float16|32|64 - сколько бит отдается

# # a = np.array([1,2,3,4,5], dtype=np.float64) - какой тип данных
# # a = np.array([[1,2,3,4,5],
# #               [6,7,8,9,0]], dtype=float)
# # списки должны иметь одинак длину 

# #a.shape - возврат размера массива (2,5)
# # a.ndim - сколько размерностей (2)
# # a.dtype('float64)
# # a.astype(int) #приведение типов

# #Размерность массивов
# # массивы хранятся последовательно (друг за другом)
# # b = a.reshape(5,2) # изменить форму, поменять размерность наоборот

# # b.reshape(-1,2) - развернуть 
# # a.reshape(5, -1)
# # b ссылается на объект а, который хранит в себе массив

# # b = a.flatten()
# # производит копирование многомерного массива в одномерный
# # вытягивает все элементы в строчку

# # b = a.ravel()
# # делает то же, что и flatten, но не копирует объект

# # c = a.T # транспонирование 

# # b = np.arange(10) # шаг (целый, дробный)

# # добавление фиктивной оси (размерность -1)
# # b[np.newaxis, :]
# # b.reshape(1, *b.shape)
# # np.expand_dims(b, axis = 0)

# # Создание массивов с особыми свойствами
# np.zeros(shape=(3,2)) # массив нулей

# np.zeros_like(a) # массив нулей такой же размерности как а

# np.ones(5) # одинарный массив

# np.eye(4) # квадратная матрица и на главной диагонали 1

# np.arange(1,10) # новый элемент в памяти с послед списком элементов

# np.arange(1,10,2) # третья цифра - шаг

# np.linspace(0,1,5, endpoint=True) # дробный шаг

# # Особенности работы с памятью

# a = np.array([1,2,3,4,5], dtype=np.float32)
# b=np.asarray(a)
# #объект указывает на те же данные, на которые указывает а
# c = np.array(a) # копия

# a = np.array([1,2,3,4,5],dtype=float32)
# b = np.asarray(a, dtype=np,int32) #если поменяли тип данных, то изменения не отразятся
# # создается новый объект

# d = [1,2,3,4,5]
# a=np.asarray(d)
# #создается новая структура - данные копируются

# # Поэлементые операции над массивами

# a = np.arange(10).reshape(2,-1)

# np.power(a,3) #возведение в степень
# # если на первое место - массив, то в степень второго числа

# a ** 3 # == np.power()

# np.add(a,2) # прибавить к каждому элементу 

# a + 2

# np.multiply(2,a) # умножает кажд эл-т 
# 2*a
# #Наоборот 

# np.power(2,a) # возведет двойку в степень элементов
# 2**a

# np.sqrt(a) # Извлекает квадратный корень

# np.exp(a) # экспанента

# np.log(1+a)
# np.log2(1+a)

# np.sin(a)

# Маски / условия / фильтры
# np.greater(a,0) # передать массив и элемент, с кот. сравниваем
# там будут булевые значения

# Агрегирующие функции 
# a.agg(axis=axis) # агрегирующая операция вдол оси аксцисс
# - выполняет редукцию (АП) по оси аксцисс 
# - удаляет ось аксцисс из исходного массива
# -  аксцисс 0 строки
# - аксцисс 1 столбцы

# np.random.seed(5555)
# a = np.random.randint(0,10, size=(3,7))
# a[1,3] = 15

# a.max(axis=0)
# получим последовательность максимальных значений по столбцам

# a.sum(axis = 1)
# получим посл-ть сумм строк 

# a.argmax() # позиция максимума в вытянутом массиве 
# a.argmax(axis=1) # позиции максимумов в каждой строке

# a.ravel()[a.argmax()] #получение элемента по индексу
# np.unravel_index(np.argmax(a), a.shape)
# получаем кортеж (индекс по строке, по столбцу)

# Операции с булевыми массивами
# a = np.asarray([True,True,False,False,True])
# a.any(), np.any(a), any(a) # Есть ли хоть 1 True

#a.all(), np.all(a), all(a) # Все ли эл-ты массива True

# np.logical_not(a) # равносильно тильде (меняет знач на противоположное)

# Бинарные операции
# a = a.astype(int)
# np.random.seed(4968)
# b = np.random.randint(0,10, size=a.shape)

#a * b # same as np.multiply(a,b)
# поэлементное умножение
# a + b # same as np.add(a,b) # поэлементное сложение

# np.fmax(a,b)
# создаст матрицу той же размерности
# вычисляет макс для каждой позиции

# np.greater(a,b)
# булевый массив False|True

# Нецелочисленные

# np.random.seed(4987)

# a= np.random.random(size=(2,5))
# b = a + np.random.rando(size=(2,5))* 1e-5

# np.isclose(a,b) 
# сравнить два массива с типом float
# создается массив того же размера с True|False

# np.isclose(a,b).all()
# эквивалентны ли 2 массива

# np.isclose(a,b).any()
# есть ли схожие элементы

# Бинарные операции над булевыми значениями
# a = np.asarray([True,True,False,False,True])
# b = np.asarray([True,False,False,True,False])
# np.logical_and(a,b) #  a = b строгое пересечение "и" оба равны True
# np.logical_or(a,b) # "или" оба True или 1 - true, 2 ß false
# np.logical_xor(a,b) # оба элемента равны False и True (не одинак)
# Битовые функции
# np.bitwise_and(a,b), np.bitwise_or(a,b), np.bitwise_xor(a,b)

# Операции с массивами разных размерностей
# a = np.arange(30).reshape(3,-1)
# b = np.arange(a.shape[1])
# a.shape = (3,10)
#b.shape=(10,)

# a + b # разные размерности
# получим массив 3 на 10 
# каждый эл-т массива а был сложен с эл-ами массива в

# если a.shape = (3,10)
# b.shape = (3,(1))
# ошибка - соседние размерности совпадали 3, 10 и 10, 2
# broadcasting 
# NP  автоматически растягивает операцию, дублируя эл-ты
# Условия: 
# a_i == b_i
# a_i == 1
# b_i == 1

# np.dot(av, bv)
# матричное переменожение, скалярное произведение между векторами

# am = np.asmatrix(av) # matrix() copy матрицы нельзя вытягивать
# bm = np.asmatrix(bv)

# привычная индексация + отрицательные индексы

# a = np.arange(15)
# variants = [ a[0:5:1], a[0:5], a[:5] ]
# print(*map(repr, variants), sep='\n')
# the same variants = [ a[slice(0,5,1)], a[slice(0,5)], a[slice(5)] ]

# Взять все элементы на четных позициях
# variants = [ a[0:len(a):2], a[0::2], a[::2]]

# Взять все элементы на нечетных позициях
# variants = [ a[1:len(a):2], a[1::2] ]

# Взять все элементы с 3 по 12 включительно с шагом 3 в обр порядке
# variants = [ a[3:13:3][::-1], a[12:2:-3], a[-3:2:-3] ]

# Булевая индексация (маски)
# np.random.seed(1234)
# a = np.random.randint(-2,7,34)
# a < 0 - Булевая маска
# a[a<0] - массив только с отриц элементами

# Найти все эл-ты кратные 3
# variants = [ a[a%3 == 0], 
#               a[np.logical_not(a%3)],
#               a[~((a%3).astype(bool))]]

# Кратны 3 или 5
# mask_3 = a%3 == 0
# mask_5 = a%5 == 0
# variants = [ a[np.logical_or(mask3, mask5)],
#               a[mask3|mask5] ]
# маска - np массив, можно передать список, он приведется
# Кратны 2 и 3
# mask_2 = a%2 == 0
# mask_3 = a%3 == 0
# variants = [ a[np.logical_and(mask2, mask3)],
#               a[mask2 & mask3],
#               a[a%6 == 0] ]

# Индексация в многомерных массивах
# хорошо - a[1,2]
# плохо - a[1][2]

# Получить строку с индексом 2
# variants = [ a[2], a[2,:] ]

# Получить столбец с индексом 3
# a[:,3]

# Получить все элементы в четных столбцах
# a[:,::2]
# вытаскиваем все строки, начало, конец с шагом 2

# элементы в первой строке и нечетных столбцах
# a[0, 1::2]

# a[1::2, 2::3][::-1]
# нечетные строки, стобцы дающие ост 2 при дел на 3 в обр порядке

# строки, в которых есть хотя бы 1 ноль
# a[(a==0).any(axis=1)]

# Получить стобцы, в кот. число полож эл-ов больше отриц
# a[:, (a>0).sum(axis=0) > (a<0).sum(axis=0)]
# True конвертируется в 1 автоматически

# Получить полож элементы
# a[a>0]

# Получить индексы полож элементов
# np.where(a > 0)
# массив с индексами строк + массив с индексами столбцов
# a[np.where(a>0)]

# np.vstack() - соединит массивы в 1
# np.vstack(np.where(a>0)).T

# Сокращенная индексация
# a[...,0] # берутся все предыдущие размерности + нулевой элемент из последней

# Генерация случайных чисел
# np.random.rand(10)
# 10 элементов в диапазоне от 0 до 1

# np.random.randint(0,10,10)

# np.random.permutation(10)
# перестановка из 10 элементов

# np.random.choice(10, size = 10)
# выбор из подмножества в каждом шаге

# Сортировки в Np
# np.sort(a.ravel()) # returns sorted copy
# a.sort(axis=0) # 1 - по строкам или 0 - по столбцам inplace sort
# a.argsort(axis=0) - отсортированный массив индексов
# a.argsort(axis=1)

# np.unique(a)# !!!!!!!!!!!
# Получение уникальных элементов